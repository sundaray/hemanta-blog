---
title: "Express.js & Node.js Interview Coding Problems"
description: "Practice problems for backend interviews."
author: "Hemanta Sundaray"
publishedAt: "2025-12-19"
tags: ["Express.js", "Node.js"]
isPublished: true
---

## Section 1: Basic Express Routes (1-5)

### Problem 1: Create a Basic Express Server

**Question:** Create an Express server that listens on port 3000 and responds with "Hello, World!" on the root route.

```typescript
import express, { Request, Response } from "express";

const app = express();

app.get("/", function (req: Request, res: Response) {
  res.send("Hello, World!");
});

app.listen(3000, function (error?: Error) {
  // Express 5: error is passed to callback instead of being thrown
  if (error) {
    console.error("Failed to start server:", error);
    process.exit(1);
  }
  console.log("Server running on port 3000");
});
```

### Problem 2: Handle Multiple HTTP Methods on Same Route

**Question:** Create a `/resource` endpoint that handles GET, POST, PUT, and DELETE methods using route chaining.

```typescript
import express, { Request, Response } from "express";

const app = express();
app.use(express.json());

app
  .route("/resource")
  .get(function (req: Request, res: Response) {
    res.json({ method: "GET", message: "Fetching resource" });
  })
  .post(function (req: Request, res: Response) {
    res.status(201).json({ method: "POST", message: "Resource created" });
  })
  .put(function (req: Request, res: Response) {
    res.json({ method: "PUT", message: "Resource updated" });
  })
  .delete(function (req: Request, res: Response) {
    res.status(204).send();
  });
```

### Problem 3: Extract Route Parameters

**Question:** Create an endpoint that extracts `userId` and `postId` from the URL `/users/:userId/posts/:postId`.

```typescript
import express, { Request, Response } from "express";

const app = express();

// Route params are captured in req.params
app.get("/users/:userId/posts/:postId", function (req: Request, res: Response) {
  const { userId, postId } = req.params;

  res.json({
    userId,
    postId,
    message: `Fetching post ${postId} for user ${userId}`,
  });
});

// Express 5: Hyphen and dot can separate params
// /flights/:from-:to matches /flights/LAX-SFO
app.get("/flights/:from-:to", function (req: Request, res: Response) {
  res.json({ from: req.params.from, to: req.params.to });
});
```

### Problem 4: Handle Query Parameters

**Question:** Create a `/search` endpoint that accepts `q`, `page`, and `limit` query parameters with defaults.

```typescript
import express, { Request, Response } from "express";

const app = express();

interface SearchQuery {
  q?: string;
  page?: string;
  limit?: string;
}

app.get(
  "/search",
  function (req: Request<{}, {}, {}, SearchQuery>, res: Response) {
    const query = req.query.q ?? "";
    const page = parseInt(req.query.page ?? "1", 10);
    const limit = parseInt(req.query.limit ?? "10", 10);

    // Validate parsed numbers
    const safePage = Number.isNaN(page) ? 1 : page;
    const safeLimit = Number.isNaN(limit) ? 10 : Math.min(limit, 100);

    res.json({
      query,
      page: safePage,
      limit: safeLimit,
      offset: (safePage - 1) * safeLimit,
    });
  },
);
```

### Problem 5: Parse JSON Request Body

**Question:** Create a POST `/users` endpoint that accepts a JSON body with `name` and `email`, validates them, and returns the created user.

```typescript
import express, { Request, Response } from "express";

const app = express();
app.use(express.json());

interface CreateUserBody {
  name: string;
  email: string;
}

app.post(
  "/users",
  function (req: Request<{}, {}, CreateUserBody>, res: Response) {
    const { name, email } = req.body;

    // Basic validation
    if (!name || typeof name !== "string") {
      res.status(400).json({ error: "Name is required" });
      return;
    }

    if (!email || !email.includes("@")) {
      res.status(400).json({ error: "Valid email is required" });
      return;
    }

    const user = {
      id: Date.now().toString(),
      name: name.trim(),
      email: email.toLowerCase(),
      createdAt: new Date().toISOString(),
    };

    res.status(201).json(user);
  },
);
```

## Section 2: Middleware (6-12)

### Problem 6: Create a Logging Middleware

**Question:** Create a middleware that logs the HTTP method, URL, and response time for every request.

```typescript
import express, { Request, Response, NextFunction } from "express";

const app = express();

function requestLogger(req: Request, res: Response, next: NextFunction): void {
  const start = Date.now();
  const { method, originalUrl } = req;

  // Listen for response finish event
  res.on("finish", function () {
    const duration = Date.now() - start;
    console.log(`${method} ${originalUrl} ${res.statusCode} - ${duration}ms`);
  });

  next();
}

// Apply to all routes
app.use(requestLogger);

app.get("/", function (req: Request, res: Response) {
  res.send("Hello!");
});
```

### Problem 7: Create an Authentication Middleware

**Question:** Create a middleware that checks for a valid Bearer token in the Authorization header.

```typescript
import express, { Request, Response, NextFunction } from "express";

const app = express();

// Extend Request type to include user
interface AuthenticatedRequest extends Request {
  user?: { id: string; role: string };
}

function authenticate(
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction,
): void {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    res.status(401).json({ error: "Missing or invalid authorization header" });
    return;
  }

  const token = authHeader.slice(7); // Remove "Bearer " prefix

  // In real app, verify JWT here
  if (token === "valid-token") {
    req.user = { id: "123", role: "admin" };
    next();
  } else {
    res.status(401).json({ error: "Invalid token" });
  }
}

// Public route
app.get("/public", function (req: Request, res: Response) {
  res.json({ message: "Public content" });
});

// Protected route - middleware applied to specific route
app.get(
  "/protected",
  authenticate,
  function (req: AuthenticatedRequest, res: Response) {
    res.json({ message: "Secret content", user: req.user });
  },
);
```

### Problem 8: Create a Request ID Middleware

**Question:** Create a middleware that assigns a unique request ID to each request for tracing.

```typescript
import express, { Request, Response, NextFunction } from "express";
import { randomUUID } from "crypto";

const app = express();

interface TracedRequest extends Request {
  requestId: string;
}

function assignRequestId(
  req: TracedRequest,
  res: Response,
  next: NextFunction,
): void {
  // Use existing header or generate new ID
  const requestId = (req.headers["x-request-id"] as string) ?? randomUUID();

  req.requestId = requestId;
  res.setHeader("X-Request-Id", requestId);

  next();
}

app.use(assignRequestId);

app.get("/", function (req: TracedRequest, res: Response) {
  res.json({ requestId: req.requestId });
});
```

### Problem 9: Apply Middleware to Specific Routes

**Question:** Create a middleware that only runs on routes starting with `/api/v1`.

```typescript
import express, { Request, Response, NextFunction } from "express";

const app = express();

function apiVersionLogger(
  req: Request,
  res: Response,
  next: NextFunction,
): void {
  console.log(`API v1 request: ${req.method} ${req.path}`);
  res.setHeader("X-API-Version", "1.0");
  next();
}

// Middleware only applies to /api/v1/* routes
app.use("/api/v1", apiVersionLogger);

app.get("/api/v1/users", function (req: Request, res: Response) {
  res.json({ users: [] }); // apiVersionLogger runs here
});

app.get("/api/v2/users", function (req: Request, res: Response) {
  res.json({ users: [] }); // apiVersionLogger does NOT run here
});
```

### Problem 10: Chain Multiple Middleware Functions

**Question:** Create a route with multiple middleware: validate input, check permissions, then handle the request.

```typescript
import express, { Request, Response, NextFunction } from "express";

const app = express();
app.use(express.json());

interface AuthRequest extends Request {
  user?: { id: string; role: string };
}

function validateBody(req: Request, res: Response, next: NextFunction): void {
  if (!req.body.title) {
    res.status(400).json({ error: "Title is required" });
    return;
  }
  next();
}

function checkPermission(
  req: AuthRequest,
  res: Response,
  next: NextFunction,
): void {
  // Simulating user from auth middleware
  req.user = { id: "1", role: "editor" };

  if (req.user.role !== "admin" && req.user.role !== "editor") {
    res.status(403).json({ error: "Insufficient permissions" });
    return;
  }
  next();
}

function createPost(req: AuthRequest, res: Response): void {
  res.status(201).json({
    id: Date.now(),
    title: req.body.title,
    authorId: req.user?.id,
  });
}

// Chain middleware as array or comma-separated
app.post("/posts", [validateBody, checkPermission], createPost);

// Alternative syntax:
// app.post("/posts", validateBody, checkPermission, createPost);
```

### Problem 11: Create Configurable Middleware

**Question:** Create a rate-limiting middleware factory that accepts `maxRequests` and `windowMs` options.

```typescript
import express, { Request, Response, NextFunction } from "express";

const app = express();

interface RateLimitOptions {
  maxRequests: number;
  windowMs: number;
}

interface RequestCount {
  count: number;
  resetTime: number;
}

function createRateLimiter(options: RateLimitOptions) {
  const { maxRequests, windowMs } = options;
  const clients = new Map<string, RequestCount>();

  return function rateLimiter(
    req: Request,
    res: Response,
    next: NextFunction,
  ): void {
    const clientIp = req.ip ?? "unknown";
    const now = Date.now();

    const clientData = clients.get(clientIp);

    // Reset if window has passed
    if (!clientData || now > clientData.resetTime) {
      clients.set(clientIp, { count: 1, resetTime: now + windowMs });
      next();
      return;
    }

    if (clientData.count >= maxRequests) {
      res.status(429).json({
        error: "Too many requests",
        retryAfter: Math.ceil((clientData.resetTime - now) / 1000),
      });
      return;
    }

    clientData.count++;
    next();
  };
}

// 100 requests per minute
app.use(createRateLimiter({ maxRequests: 100, windowMs: 60000 }));

app.get("/", function (req: Request, res: Response) {
  res.json({ message: "OK" });
});
```

### Problem 12: Error Handling Middleware

**Question:** Create a global error handling middleware that handles different error types.

```typescript
import express, { Request, Response, NextFunction } from "express";

const app = express();
app.use(express.json());

// Custom error classes
class AppError extends Error {
  constructor(
    public statusCode: number,
    public message: string,
    public isOperational = true,
  ) {
    super(message);
    Object.setPrototypeOf(this, AppError.prototype);
  }
}

class NotFoundError extends AppError {
  constructor(resource: string) {
    super(404, `${resource} not found`);
  }
}

class ValidationError extends AppError {
  constructor(message: string) {
    super(400, message);
  }
}

// Route that throws errors
app.get("/users/:id", function (req: Request, res: Response) {
  if (req.params.id === "0") {
    throw new NotFoundError("User");
  }
  res.json({ id: req.params.id, name: "John" });
});

// Error handling middleware - MUST have 4 parameters
function errorHandler(
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction,
): void {
  console.error(`Error: ${err.message}`);

  if (err instanceof AppError) {
    res.status(err.statusCode).json({
      error: err.message,
      ...(process.env.NODE_ENV === "development" && { stack: err.stack }),
    });
    return;
  }

  // Unknown errors
  res.status(500).json({
    error:
      process.env.NODE_ENV === "production"
        ? "Internal server error"
        : err.message,
  });
}

// Must be registered LAST
app.use(errorHandler);
```

## Section 3: Async Operations (13-18)

### Problem 13: Read File and Return Contents

**Question:** Create an endpoint that reads a file asynchronously and returns its contents.

```typescript
import express, { Request, Response } from "express";
import { readFile } from "fs/promises";
import path from "path";

const app = express();

app.get("/files/:filename", async function (req: Request, res: Response) {
  const { filename } = req.params;

  // Prevent directory traversal attacks
  const safeName = path.basename(filename);
  const filePath = path.join(__dirname, "data", safeName);

  try {
    const content = await readFile(filePath, "utf-8");
    res.type("text/plain").send(content);
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === "ENOENT") {
      res.status(404).json({ error: "File not found" });
    } else {
      // Express 5 auto-catches rejected promises and forwards to error handler
      throw error;
    }
  }
});
```

### Problem 14: Write Data to File

**Question:** Create a POST endpoint that saves request body to a JSON file.

```typescript
import express, { Request, Response } from "express";
import { writeFile, mkdir } from "fs/promises";
import path from "path";

const app = express();
app.use(express.json());

const DATA_DIR = path.join(__dirname, "data");

app.post("/save", async function (req: Request, res: Response) {
  const { name, content } = req.body;

  if (!name || !content) {
    res.status(400).json({ error: "Name and content are required" });
    return;
  }

  // Sanitize filename
  const safeName = name.replace(/[^a-zA-Z0-9-_]/g, "_");
  const filePath = path.join(DATA_DIR, `${safeName}.json`);

  try {
    // Ensure directory exists
    await mkdir(DATA_DIR, { recursive: true });

    await writeFile(
      filePath,
      JSON.stringify({ content, savedAt: new Date() }, null, 2),
    );

    res.status(201).json({ message: "File saved", path: `${safeName}.json` });
  } catch (error) {
    throw error; // Express 5 forwards to error handler
  }
});
```

### Problem 15: Make External API Call

**Question:** Create an endpoint that fetches data from an external API using the native fetch.

```typescript
import express, { Request, Response } from "express";

const app = express();

interface GitHubUser {
  login: string;
  name: string;
  public_repos: number;
}

app.get("/github/:username", async function (req: Request, res: Response) {
  const { username } = req.params;

  try {
    const response = await fetch(`https://api.github.com/users/${username}`, {
      headers: {
        Accept: "application/vnd.github.v3+json",
        "User-Agent": "Express-App",
      },
    });

    if (!response.ok) {
      if (response.status === 404) {
        res.status(404).json({ error: "User not found" });
        return;
      }
      throw new Error(`GitHub API error: ${response.status}`);
    }

    const data: GitHubUser = await response.json();

    res.json({
      username: data.login,
      name: data.name,
      publicRepos: data.public_repos,
    });
  } catch (error) {
    if (error instanceof TypeError) {
      // Network error
      res.status(503).json({ error: "Unable to reach GitHub API" });
      return;
    }
    throw error;
  }
});
```

### Problem 16: Handle Sequential Async Operations

**Question:** Create an endpoint that performs sequential database-like operations (fetch user, then fetch their orders).

```typescript
import express, { Request, Response } from "express";

const app = express();

// Simulated async database functions
async function findUserById(
  id: string,
): Promise<{ id: string; name: string } | null> {
  await new Promise((resolve) => setTimeout(resolve, 100));
  if (id === "1") return { id: "1", name: "John" };
  return null;
}

async function findOrdersByUserId(
  userId: string,
): Promise<Array<{ id: string; total: number }>> {
  await new Promise((resolve) => setTimeout(resolve, 100));
  return [
    { id: "o1", total: 99.99 },
    { id: "o2", total: 149.99 },
  ];
}

app.get("/users/:id/orders", async function (req: Request, res: Response) {
  const { id } = req.params;

  // Sequential: first get user, then get orders
  const user = await findUserById(id);

  if (!user) {
    res.status(404).json({ error: "User not found" });
    return;
  }

  const orders = await findOrdersByUserId(user.id);

  res.json({
    user,
    orders,
    totalSpent: orders.reduce((sum, order) => sum + order.total, 0),
  });
});
```

### Problem 17: Handle Parallel Async Operations

**Question:** Create an endpoint that fetches data from multiple sources in parallel.

```typescript
import express, { Request, Response } from "express";

const app = express();

// Simulated async data sources
async function fetchUserProfile(id: string) {
  await new Promise((resolve) => setTimeout(resolve, 200));
  return { id, name: "John", email: "john@example.com" };
}

async function fetchUserStats(id: string) {
  await new Promise((resolve) => setTimeout(resolve, 150));
  return { posts: 42, followers: 1000, following: 500 };
}

async function fetchUserPreferences(id: string) {
  await new Promise((resolve) => setTimeout(resolve, 100));
  return { theme: "dark", notifications: true };
}

app.get("/users/:id/dashboard", async function (req: Request, res: Response) {
  const { id } = req.params;

  // Parallel execution - all requests start simultaneously
  const [profile, stats, preferences] = await Promise.all([
    fetchUserProfile(id),
    fetchUserStats(id),
    fetchUserPreferences(id),
  ]);

  res.json({ profile, stats, preferences });
});

// Alternative: Handle partial failures with Promise.allSettled
app.get(
  "/users/:id/dashboard-safe",
  async function (req: Request, res: Response) {
    const { id } = req.params;

    const results = await Promise.allSettled([
      fetchUserProfile(id),
      fetchUserStats(id),
      fetchUserPreferences(id),
    ]);

    // Extract values, using null for failures
    const [profile, stats, preferences] = results.map((result) =>
      result.status === "fulfilled" ? result.value : null,
    );

    res.json({
      profile,
      stats,
      preferences,
      _meta: {
        profileLoaded: results[0].status === "fulfilled",
        statsLoaded: results[1].status === "fulfilled",
        preferencesLoaded: results[2].status === "fulfilled",
      },
    });
  },
);
```

### Problem 18: Implement Request Timeout

**Question:** Create a middleware that aborts requests taking longer than a specified timeout.

```typescript
import express, { Request, Response, NextFunction } from "express";

const app = express();

function timeout(ms: number) {
  return function (req: Request, res: Response, next: NextFunction): void {
    const timeoutId = setTimeout(function () {
      if (!res.headersSent) {
        res.status(504).json({ error: "Request timeout" });
      }
    }, ms);

    // Clear timeout when response finishes
    res.on("finish", function () {
      clearTimeout(timeoutId);
    });

    next();
  };
}

// Apply 5 second timeout to all routes
app.use(timeout(5000));

// Simulated slow endpoint
app.get("/slow", async function (req: Request, res: Response) {
  await new Promise((resolve) => setTimeout(resolve, 3000));

  // Only send if not already timed out
  if (!res.headersSent) {
    res.json({ message: "Completed" });
  }
});

// Using AbortController for fetch with timeout
app.get("/external", async function (req: Request, res: Response) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 3000);

  try {
    const response = await fetch("https://api.example.com/data", {
      signal: controller.signal,
    });
    clearTimeout(timeoutId);

    const data = await response.json();
    res.json(data);
  } catch (error) {
    clearTimeout(timeoutId);
    if (error instanceof Error && error.name === "AbortError") {
      res.status(504).json({ error: "External API timeout" });
    } else {
      throw error;
    }
  }
});
```

## Section 4: Express Router & Modular Routes (19-22)

### Problem 19: Create a Modular Router

**Question:** Create a modular router for user-related routes in a separate file.

```typescript
// users.router.ts
import { Router, Request, Response } from "express";

const router = Router();

// Middleware specific to this router
router.use(function (req: Request, res: Response, next) {
  console.log(`Users router: ${req.method} ${req.path}`);
  next();
});

router.get("/", function (req: Request, res: Response) {
  res.json({ users: [{ id: 1, name: "John" }] });
});

router.get("/:id", function (req: Request, res: Response) {
  res.json({ id: req.params.id, name: "John" });
});

router.post("/", function (req: Request, res: Response) {
  res.status(201).json({ id: Date.now(), ...req.body });
});

export default router;

// app.ts
import express from "express";
import usersRouter from "./users.router";

const app = express();
app.use(express.json());

// Mount router at /api/users
app.use("/api/users", usersRouter);

// Routes become: GET /api/users, GET /api/users/:id, POST /api/users
```

### Problem 20: Nested Routers with Param Inheritance

**Question:** Create nested routers where child router accesses parent route params.

```typescript
import express, { Router, Request, Response } from "express";

const app = express();
app.use(express.json());

// Posts router - child router
const postsRouter = Router({ mergeParams: true }); // Required to access parent params

postsRouter.get("/", function (req: Request, res: Response) {
  const { userId } = req.params;
  res.json({
    message: `All posts for user ${userId}`,
    posts: [],
  });
});

postsRouter.get("/:postId", function (req: Request, res: Response) {
  const { userId, postId } = req.params;
  res.json({
    userId,
    postId,
    title: "Sample Post",
  });
});

// Users router - parent router
const usersRouter = Router();

usersRouter.get("/:userId", function (req: Request, res: Response) {
  res.json({ id: req.params.userId, name: "John" });
});

// Mount posts router as child of users
usersRouter.use("/:userId/posts", postsRouter);

app.use("/users", usersRouter);

// Available routes:
// GET /users/:userId
// GET /users/:userId/posts
// GET /users/:userId/posts/:postId
```

### Problem 21: Route with Optional Parameters (Express 5 Syntax)

**Question:** Create a route that handles optional file extension in the URL.

```typescript
import express, { Request, Response } from "express";

const app = express();

// Express 5: Use braces {} for optional segments instead of ?
// Matches: /files/report and /files/report.json
app.get("/files/:name{.:ext}", function (req: Request, res: Response) {
  const { name, ext } = req.params;

  const format = ext ?? "json"; // Default to json if no extension

  const data = { id: 1, name: "Sample Report", generatedAt: new Date() };

  if (format === "json") {
    res.json(data);
  } else if (format === "xml") {
    res
      .type("application/xml")
      .send(`<report><name>${data.name}</name></report>`);
  } else {
    res.status(400).json({ error: `Unsupported format: ${format}` });
  }
});

// Express 5: Wildcard must be named
// Matches any path under /static/
app.get("/static/{*filepath}", function (req: Request, res: Response) {
  res.json({ requestedPath: req.params.filepath });
});
```

### Problem 22: Skip to Next Route Handler

**Question:** Implement route handlers that can skip to the next matching route using `next('route')`.

```typescript
import express, { Request, Response, NextFunction } from "express";

const app = express();

// First handler for /users/:id - handles special case
app.get(
  "/users/:id",
  function (req: Request, res: Response, next: NextFunction) {
    // Special handling for user ID "0"
    if (req.params.id === "0") {
      next("route"); // Skip remaining handlers, go to next route definition
      return;
    }

    // Normal case - continue to next handler in this stack
    next();
  },
  function (req: Request, res: Response) {
    res.json({ id: req.params.id, name: "Regular User" });
  },
);

// Second route definition for /users/:id - handles user "0"
app.get("/users/:id", function (req: Request, res: Response) {
  res.json({ id: "0", name: "System User", isSpecial: true });
});

// Result:
// GET /users/5  → { id: "5", name: "Regular User" }
// GET /users/0  → { id: "0", name: "System User", isSpecial: true }
```

## Section 5: Input Validation & Security (23-26)

### Problem 23: Input Validation Middleware

**Question:** Create a generic validation middleware factory.

```typescript
import express, { Request, Response, NextFunction } from "express";

const app = express();
app.use(express.json());

// Generic validation types
type ValidationRule<T> = (value: T) => string | null; // Returns error message or null

interface ValidationSchema {
  [field: string]: ValidationRule<unknown>[];
}

function validate(
  schema: ValidationSchema,
  source: "body" | "query" | "params",
) {
  return function (req: Request, res: Response, next: NextFunction): void {
    const data = req[source];
    const errors: Record<string, string[]> = {};

    for (const [field, rules] of Object.entries(schema)) {
      const value = data[field];
      const fieldErrors: string[] = [];

      for (const rule of rules) {
        const error = rule(value);
        if (error) fieldErrors.push(error);
      }

      if (fieldErrors.length > 0) {
        errors[field] = fieldErrors;
      }
    }

    if (Object.keys(errors).length > 0) {
      res.status(400).json({ errors });
      return;
    }

    next();
  };
}

// Validation helpers
const required: ValidationRule<unknown> = (value) =>
  value === undefined || value === "" ? "Field is required" : null;

const isString: ValidationRule<unknown> = (value) =>
  value !== undefined && typeof value !== "string" ? "Must be a string" : null;

const minLength =
  (min: number): ValidationRule<unknown> =>
  (value) =>
    typeof value === "string" && value.length < min
      ? `Must be at least ${min} characters`
      : null;

const isEmail: ValidationRule<unknown> = (value) =>
  typeof value === "string" && !value.includes("@")
    ? "Must be a valid email"
    : null;

// Usage
const createUserSchema: ValidationSchema = {
  name: [required, isString, minLength(2)],
  email: [required, isString, isEmail],
};

app.post(
  "/users",
  validate(createUserSchema, "body"),
  function (req: Request, res: Response) {
    res.status(201).json({ user: req.body });
  },
);
```

### Problem 24: Sanitize User Input

**Question:** Create middleware to sanitize string inputs to prevent XSS.

```typescript
import express, { Request, Response, NextFunction } from "express";

const app = express();
app.use(express.json());

function escapeHtml(str: string): string {
  const htmlEntities: Record<string, string> = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
  };
  return str.replace(/[&<>"']/g, (char) => htmlEntities[char]);
}

function sanitizeObject(obj: unknown): unknown {
  if (typeof obj === "string") {
    return escapeHtml(obj);
  }

  if (Array.isArray(obj)) {
    return obj.map(sanitizeObject);
  }

  if (obj !== null && typeof obj === "object") {
    const sanitized: Record<string, unknown> = {};
    for (const [key, value] of Object.entries(obj)) {
      sanitized[key] = sanitizeObject(value);
    }
    return sanitized;
  }

  return obj;
}

function sanitizeBody(req: Request, res: Response, next: NextFunction): void {
  if (req.body) {
    req.body = sanitizeObject(req.body);
  }
  next();
}

app.use(sanitizeBody);

app.post("/comments", function (req: Request, res: Response) {
  // req.body.content is already sanitized
  res.status(201).json({ comment: req.body });
});

// Input:  { "content": "<script>alert('xss')</script>" }
// Output: { "content": "&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;" }
```

### Problem 25: CORS Middleware

**Question:** Implement a CORS middleware that handles preflight requests.

```typescript
import express, { Request, Response, NextFunction } from "express";

const app = express();

interface CorsOptions {
  origin: string | string[];
  methods?: string[];
  allowedHeaders?: string[];
  credentials?: boolean;
  maxAge?: number;
}

function cors(options: CorsOptions) {
  const {
    origin,
    methods = ["GET", "POST", "PUT", "DELETE", "PATCH"],
    allowedHeaders = ["Content-Type", "Authorization"],
    credentials = false,
    maxAge = 86400,
  } = options;

  return function (req: Request, res: Response, next: NextFunction): void {
    const requestOrigin = req.headers.origin ?? "";

    // Check if origin is allowed
    const isAllowed = Array.isArray(origin)
      ? origin.includes(requestOrigin)
      : origin === "*" || origin === requestOrigin;

    if (isAllowed) {
      res.setHeader(
        "Access-Control-Allow-Origin",
        origin === "*" ? "*" : requestOrigin,
      );
    }

    if (credentials) {
      res.setHeader("Access-Control-Allow-Credentials", "true");
    }

    // Handle preflight request
    if (req.method === "OPTIONS") {
      res.setHeader("Access-Control-Allow-Methods", methods.join(", "));
      res.setHeader("Access-Control-Allow-Headers", allowedHeaders.join(", "));
      res.setHeader("Access-Control-Max-Age", maxAge.toString());
      res.status(204).send();
      return;
    }

    next();
  };
}

app.use(
  cors({
    origin: ["http://localhost:3000", "https://myapp.com"],
    credentials: true,
  }),
);

app.get("/api/data", function (req: Request, res: Response) {
  res.json({ data: "Hello from API" });
});
```

### Problem 26: Request Body Size Limit

**Question:** Create middleware that limits request body size.

```typescript
import express, { Request, Response, NextFunction } from "express";

const app = express();

function limitBodySize(maxBytes: number) {
  return function (req: Request, res: Response, next: NextFunction): void {
    const contentLength = parseInt(req.headers["content-length"] ?? "0", 10);

    if (contentLength > maxBytes) {
      res.status(413).json({
        error: "Payload too large",
        maxSize: `${maxBytes} bytes`,
      });
      return;
    }

    // Also check actual body size during streaming
    let receivedBytes = 0;

    req.on("data", function (chunk: Buffer) {
      receivedBytes += chunk.length;

      if (receivedBytes > maxBytes) {
        res.status(413).json({ error: "Payload too large" });
        req.destroy(); // Stop receiving data
      }
    });

    next();
  };
}

// Limit to 1MB
app.use(limitBodySize(1024 * 1024));
app.use(express.json());

app.post("/upload", function (req: Request, res: Response) {
  res.json({ received: true, size: JSON.stringify(req.body).length });
});
```

## Section 6: Real-World Patterns (27-30)

### Problem 27: Simple In-Memory CRUD API

**Question:** Implement a complete CRUD API for a "todos" resource with in-memory storage.

```typescript
import express, { Request, Response } from "express";

const app = express();
app.use(express.json());

interface Todo {
  id: string;
  title: string;
  completed: boolean;
  createdAt: Date;
  updatedAt: Date;
}

// In-memory storage
const todos = new Map<string, Todo>();

// CREATE
app.post("/todos", function (req: Request, res: Response) {
  const { title } = req.body;

  if (!title || typeof title !== "string") {
    res.status(400).json({ error: "Title is required" });
    return;
  }

  const todo: Todo = {
    id: Date.now().toString(36),
    title,
    completed: false,
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  todos.set(todo.id, todo);
  res.status(201).json(todo);
});

// READ ALL
app.get("/todos", function (req: Request, res: Response) {
  const { completed } = req.query;

  let result = Array.from(todos.values());

  // Filter by completed status if provided
  if (completed !== undefined) {
    const isCompleted = completed === "true";
    result = result.filter((todo) => todo.completed === isCompleted);
  }

  res.json(result);
});

// READ ONE
app.get("/todos/:id", function (req: Request, res: Response) {
  const todo = todos.get(req.params.id);

  if (!todo) {
    res.status(404).json({ error: "Todo not found" });
    return;
  }

  res.json(todo);
});

// UPDATE
app.patch("/todos/:id", function (req: Request, res: Response) {
  const todo = todos.get(req.params.id);

  if (!todo) {
    res.status(404).json({ error: "Todo not found" });
    return;
  }

  const { title, completed } = req.body;

  if (title !== undefined) todo.title = title;
  if (completed !== undefined) todo.completed = completed;
  todo.updatedAt = new Date();

  res.json(todo);
});

// DELETE
app.delete("/todos/:id", function (req: Request, res: Response) {
  const existed = todos.delete(req.params.id);

  if (!existed) {
    res.status(404).json({ error: "Todo not found" });
    return;
  }

  res.status(204).send();
});
```

### Problem 28: Health Check Endpoint with Dependencies

**Question:** Create a health check endpoint that verifies database and external service connections.

```typescript
import express, { Request, Response } from "express";

const app = express();

interface HealthStatus {
  status: "healthy" | "degraded" | "unhealthy";
  timestamp: string;
  uptime: number;
  checks: Record<string, CheckResult>;
}

interface CheckResult {
  status: "pass" | "fail";
  latency?: number;
  message?: string;
}

// Simulated dependency checks
async function checkDatabase(): Promise<CheckResult> {
  const start = Date.now();
  try {
    // Simulate DB ping
    await new Promise((resolve, reject) => {
      setTimeout(() => {
        Math.random() > 0.1
          ? resolve(true)
          : reject(new Error("Connection timeout"));
      }, 50);
    });
    return { status: "pass", latency: Date.now() - start };
  } catch (error) {
    return { status: "fail", message: (error as Error).message };
  }
}

async function checkRedis(): Promise<CheckResult> {
  const start = Date.now();
  try {
    await new Promise((resolve) => setTimeout(resolve, 30));
    return { status: "pass", latency: Date.now() - start };
  } catch (error) {
    return { status: "fail", message: (error as Error).message };
  }
}

async function checkExternalApi(): Promise<CheckResult> {
  const start = Date.now();
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 2000);

    const response = await fetch("https://api.github.com", {
      signal: controller.signal,
    });
    clearTimeout(timeoutId);

    return {
      status: response.ok ? "pass" : "fail",
      latency: Date.now() - start,
    };
  } catch {
    return {
      status: "fail",
      message: "Request failed",
      latency: Date.now() - start,
    };
  }
}

// Liveness probe - is the service running?
app.get("/health/live", function (req: Request, res: Response) {
  res.json({ status: "alive" });
});

// Readiness probe - is the service ready to accept traffic?
app.get("/health/ready", async function (req: Request, res: Response) {
  const checks = {
    database: await checkDatabase(),
    redis: await checkRedis(),
    externalApi: await checkExternalApi(),
  };

  const allPassing = Object.values(checks).every((c) => c.status === "pass");
  const anyPassing = Object.values(checks).some((c) => c.status === "pass");

  const status: HealthStatus = {
    status: allPassing ? "healthy" : anyPassing ? "degraded" : "unhealthy",
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    checks,
  };

  // Return 503 if unhealthy (k8s will not route traffic)
  const httpStatus = status.status === "unhealthy" ? 503 : 200;
  res.status(httpStatus).json(status);
});
```

### Problem 29: Streaming Response

**Question:** Implement an endpoint that streams data to the client.

```typescript
import express, { Request, Response } from "express";
import { Readable } from "stream";

const app = express();

// Stream JSON array items one by one
app.get("/stream/items", function (req: Request, res: Response) {
  res.setHeader("Content-Type", "application/json");
  res.setHeader("Transfer-Encoding", "chunked");

  res.write("["); // Start JSON array

  let count = 0;
  const maxItems = 10;

  const interval = setInterval(function () {
    if (count >= maxItems) {
      clearInterval(interval);
      res.write("]"); // End JSON array
      res.end();
      return;
    }

    const item = JSON.stringify({
      id: count,
      timestamp: Date.now(),
      data: `Item ${count}`,
    });

    // Add comma separator except for first item
    res.write(count > 0 ? "," + item : item);
    count++;
  }, 500);

  // Clean up if client disconnects
  req.on("close", function () {
    clearInterval(interval);
  });
});

// Server-Sent Events (SSE) endpoint
app.get("/stream/events", function (req: Request, res: Response) {
  res.setHeader("Content-Type", "text/event-stream");
  res.setHeader("Cache-Control", "no-cache");
  res.setHeader("Connection", "keep-alive");
  res.flushHeaders();

  let eventId = 0;

  const sendEvent = function () {
    const data = {
      id: eventId,
      message: `Event ${eventId}`,
      time: new Date().toISOString(),
    };

    // SSE format: "event: name\ndata: payload\nid: id\n\n"
    res.write(`event: update\n`);
    res.write(`data: ${JSON.stringify(data)}\n`);
    res.write(`id: ${eventId}\n\n`);

    eventId++;
  };

  // Send event every 2 seconds
  const interval = setInterval(sendEvent, 2000);
  sendEvent(); // Send first event immediately

  req.on("close", function () {
    clearInterval(interval);
  });
});

// Stream file content
app.get("/stream/file", async function (req: Request, res: Response) {
  const { createReadStream } = await import("fs");
  const { stat } = await import("fs/promises");
  const path = await import("path");

  const filePath = path.join(__dirname, "large-file.txt");

  try {
    const stats = await stat(filePath);

    res.setHeader("Content-Type", "text/plain");
    res.setHeader("Content-Length", stats.size);

    const stream = createReadStream(filePath);
    stream.pipe(res);

    stream.on("error", function (error) {
      if (!res.headersSent) {
        res.status(500).json({ error: "Stream error" });
      }
    });
  } catch {
    res.status(404).json({ error: "File not found" });
  }
});
```

### Problem 30: Graceful Shutdown

**Question:** Implement graceful shutdown that waits for ongoing requests to complete.

```typescript
import express, { Request, Response } from "express";
import { createServer, Server } from "http";

const app = express();

// Track active connections
const connections = new Set<import("net").Socket>();

app.get("/", async function (req: Request, res: Response) {
  // Simulate slow operation
  await new Promise((resolve) => setTimeout(resolve, 2000));
  res.json({ message: "Hello", pid: process.pid });
});

app.get("/health", function (req: Request, res: Response) {
  res.json({ status: "healthy" });
});

const server: Server = createServer(app);

// Track connections for graceful shutdown
server.on("connection", function (socket) {
  connections.add(socket);
  socket.on("close", function () {
    connections.delete(socket);
  });
});

function shutdown(signal: string) {
  console.log(`\n${signal} received. Starting graceful shutdown...`);

  // Stop accepting new connections
  server.close(function (err) {
    if (err) {
      console.error("Error during shutdown:", err);
      process.exit(1);
    }

    console.log("All connections closed. Exiting.");
    process.exit(0);
  });

  // Force close after timeout
  const forceShutdownTimeout = setTimeout(function () {
    console.error("Forcing shutdown after timeout");

    // Close all remaining connections
    for (const socket of connections) {
      socket.destroy();
    }

    process.exit(1);
  }, 10000); // 10 second timeout

  // Don't let this timer keep the process alive
  forceShutdownTimeout.unref();

  // Close idle keep-alive connections
  server.closeIdleConnections();
}

// Handle shutdown signals
process.on("SIGTERM", () => shutdown("SIGTERM"));
process.on("SIGINT", () => shutdown("SIGINT"));

// Handle uncaught errors
process.on("uncaughtException", function (error) {
  console.error("Uncaught exception:", error);
  shutdown("uncaughtException");
});

process.on("unhandledRejection", function (reason) {
  console.error("Unhandled rejection:", reason);
  // Don't exit immediately - log for monitoring
});

const PORT = process.env.PORT ?? 3000;

server.listen(PORT, function () {
  console.log(`Server running on port ${PORT}`);
  console.log(`Process ID: ${process.pid}`);
});
```

## Quick Reference: Express 5 Changes

```typescript
// ❌ Express 4 (deprecated)
app.get("/*", handler); // Unnamed wildcard
app.get("/file.:ext?", handler); // Optional with ?
res.send(data, 200); // Status as second arg
res.json(data, 201); // Status as second arg
res.redirect("/back"); // Magic "back" string
req.param("name"); // Get any param source

// ✅ Express 5 (correct)
app.get("/{*splat}", handler); // Named wildcard (includes root)
app.get("/*splat", handler); // Named wildcard (excludes root)
app.get("/file{.:ext}", handler); // Optional with braces
res.status(200).send(data); // Chain status first
res.status(201).json(data); // Chain status first
res.redirect(req.get("Referrer") || "/"); // Explicit referrer
req.params.name || req.body.name; // Explicit source

// Promise handling (auto in Express 5)
app.get("/async", async function (req, res) {
  const data = await fetchData(); // Errors auto-forwarded to error handler
  res.json(data);
});

// app.listen error handling (Express 5)
app.listen(3000, function (error?: Error) {
  if (error) throw error; // Error passed to callback
  console.log("Running");
});
```

## Section 7: Additional Common Interview Topics (31-36)

### Problem 31: JWT Authentication (Sign & Verify)

**Question:** Implement login and protected routes using JWT tokens.

```typescript
import express, { Request, Response, NextFunction } from "express";
import jwt from "jsonwebtoken";

const app = express();
app.use(express.json());

const JWT_SECRET = process.env.JWT_SECRET ?? "your-secret-key";
const JWT_EXPIRES_IN = "1h";

interface UserPayload {
  userId: string;
  email: string;
  role: string;
}

interface AuthRequest extends Request {
  user?: UserPayload;
}

// Simulated user database
const users = new Map([
  [
    "1",
    {
      id: "1",
      email: "john@example.com",
      password: "hashed_password",
      role: "admin",
    },
  ],
]);

// Login - Issue JWT
app.post("/auth/login", async function (req: Request, res: Response) {
  const { email, password } = req.body;

  // Find user (in real app, query database)
  const user = Array.from(users.values()).find((u) => u.email === email);

  if (!user) {
    res.status(401).json({ error: "Invalid credentials" });
    return;
  }

  // In real app, use bcrypt.compare(password, user.password)
  const passwordValid = password === "secret123";

  if (!passwordValid) {
    res.status(401).json({ error: "Invalid credentials" });
    return;
  }

  // Create JWT payload (never include sensitive data)
  const payload: UserPayload = {
    userId: user.id,
    email: user.email,
    role: user.role,
  };

  // Sign token
  const token = jwt.sign(payload, JWT_SECRET, {
    expiresIn: JWT_EXPIRES_IN,
    issuer: "my-app",
  });

  // Optional: Create refresh token with longer expiry
  const refreshToken = jwt.sign({ userId: user.id }, JWT_SECRET, {
    expiresIn: "7d",
  });

  res.json({
    accessToken: token,
    refreshToken,
    expiresIn: 3600,
  });
});

// Verify JWT Middleware
function authenticate(
  req: AuthRequest,
  res: Response,
  next: NextFunction,
): void {
  const authHeader = req.headers.authorization;

  if (!authHeader?.startsWith("Bearer ")) {
    res.status(401).json({ error: "Missing authorization header" });
    return;
  }

  const token = authHeader.slice(7);

  try {
    const decoded = jwt.verify(token, JWT_SECRET, {
      issuer: "my-app",
    }) as UserPayload;

    req.user = decoded;
    next();
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      res.status(401).json({ error: "Token expired" });
    } else if (error instanceof jwt.JsonWebTokenError) {
      res.status(401).json({ error: "Invalid token" });
    } else {
      res.status(401).json({ error: "Authentication failed" });
    }
  }
}

// Role-based authorization middleware factory
function authorize(...allowedRoles: string[]) {
  return function (req: AuthRequest, res: Response, next: NextFunction): void {
    if (!req.user) {
      res.status(401).json({ error: "Not authenticated" });
      return;
    }

    if (!allowedRoles.includes(req.user.role)) {
      res.status(403).json({ error: "Insufficient permissions" });
      return;
    }

    next();
  };
}

// Protected route
app.get("/profile", authenticate, function (req: AuthRequest, res: Response) {
  res.json({ user: req.user });
});

// Admin-only route
app.delete(
  "/users/:id",
  authenticate,
  authorize("admin"),
  function (req: AuthRequest, res: Response) {
    res.json({
      message: `User ${req.params.id} deleted by ${req.user?.email}`,
    });
  },
);

// Refresh token endpoint
app.post("/auth/refresh", function (req: Request, res: Response) {
  const { refreshToken } = req.body;

  if (!refreshToken) {
    res.status(400).json({ error: "Refresh token required" });
    return;
  }

  try {
    const decoded = jwt.verify(refreshToken, JWT_SECRET) as { userId: string };
    const user = users.get(decoded.userId);

    if (!user) {
      res.status(401).json({ error: "User not found" });
      return;
    }

    // Issue new access token
    const newToken = jwt.sign(
      { userId: user.id, email: user.email, role: user.role },
      JWT_SECRET,
      { expiresIn: JWT_EXPIRES_IN },
    );

    res.json({ accessToken: newToken });
  } catch {
    res.status(401).json({ error: "Invalid refresh token" });
  }
});
```

### Problem 32: Pagination (Offset & Cursor-Based)

**Question:** Implement both offset-based and cursor-based pagination for a list endpoint.

```typescript
import express, { Request, Response } from "express";

const app = express();

// Simulated database with 100 items
const items = Array.from({ length: 100 }, (_, i) => ({
  id: (i + 1).toString(),
  name: `Item ${i + 1}`,
  createdAt: new Date(Date.now() - i * 86400000).toISOString(), // Each item 1 day apart
}));

// ===== OFFSET-BASED PAGINATION =====
// Simple but has issues: slow on large datasets, inconsistent if data changes

interface OffsetQuery {
  page?: string;
  limit?: string;
}

app.get(
  "/items/offset",
  function (req: Request<{}, {}, {}, OffsetQuery>, res: Response) {
    const page = Math.max(1, parseInt(req.query.page ?? "1", 10));
    const limit = Math.min(
      100,
      Math.max(1, parseInt(req.query.limit ?? "10", 10)),
    );

    const offset = (page - 1) * limit;
    const totalItems = items.length;
    const totalPages = Math.ceil(totalItems / limit);

    const paginatedItems = items.slice(offset, offset + limit);

    res.json({
      data: paginatedItems,
      pagination: {
        currentPage: page,
        itemsPerPage: limit,
        totalItems,
        totalPages,
        hasNextPage: page < totalPages,
        hasPrevPage: page > 1,
      },
    });
  },
);

// ===== CURSOR-BASED PAGINATION =====
// Better for real-time data, infinite scroll, large datasets
// Cursor is typically an encoded value (ID, timestamp, or composite)

interface CursorQuery {
  cursor?: string;
  limit?: string;
  direction?: "next" | "prev";
}

function encodeCursor(id: string, createdAt: string): string {
  // Base64 encode the cursor data
  return Buffer.from(JSON.stringify({ id, createdAt })).toString("base64url");
}

function decodeCursor(
  cursor: string,
): { id: string; createdAt: string } | null {
  try {
    return JSON.parse(Buffer.from(cursor, "base64url").toString("utf-8"));
  } catch {
    return null;
  }
}

app.get(
  "/items/cursor",
  function (req: Request<{}, {}, {}, CursorQuery>, res: Response) {
    const limit = Math.min(
      100,
      Math.max(1, parseInt(req.query.limit ?? "10", 10)),
    );
    const cursor = req.query.cursor;
    const direction = req.query.direction ?? "next";

    let startIndex = 0;

    if (cursor) {
      const decoded = decodeCursor(cursor);

      if (!decoded) {
        res.status(400).json({ error: "Invalid cursor" });
        return;
      }

      // Find item matching cursor
      const cursorIndex = items.findIndex((item) => item.id === decoded.id);

      if (cursorIndex === -1) {
        res.status(400).json({ error: "Cursor item not found" });
        return;
      }

      // Start after/before the cursor item
      startIndex =
        direction === "next"
          ? cursorIndex + 1
          : Math.max(0, cursorIndex - limit);
    }

    const paginatedItems = items.slice(startIndex, startIndex + limit);

    // Generate cursors for next/prev pages
    const firstItem = paginatedItems[0];
    const lastItem = paginatedItems[paginatedItems.length - 1];

    const hasMore = startIndex + limit < items.length;
    const hasPrev = startIndex > 0;

    res.json({
      data: paginatedItems,
      pagination: {
        nextCursor:
          hasMore && lastItem
            ? encodeCursor(lastItem.id, lastItem.createdAt)
            : null,
        prevCursor:
          hasPrev && firstItem
            ? encodeCursor(firstItem.id, firstItem.createdAt)
            : null,
        hasMore,
        hasPrev,
      },
    });
  },
);

// ===== KEYSET PAGINATION =====
// Most efficient for databases - uses WHERE clause instead of OFFSET
// This is the SQL pattern (shown as pseudocode since we're using in-memory data)

app.get("/items/keyset", function (req: Request, res: Response) {
  const limit = Math.min(
    100,
    parseInt((req.query.limit as string) ?? "10", 10),
  );
  const afterId = req.query.after_id as string | undefined;

  let filteredItems = items;

  if (afterId) {
    const afterIndex = items.findIndex((item) => item.id === afterId);
    if (afterIndex !== -1) {
      filteredItems = items.slice(afterIndex + 1);
    }
  }

  const paginatedItems = filteredItems.slice(0, limit);
  const lastItem = paginatedItems[paginatedItems.length - 1];

  // In SQL this would be:
  // SELECT * FROM items
  // WHERE id > :after_id
  // ORDER BY id ASC
  // LIMIT :limit

  res.json({
    data: paginatedItems,
    next_after_id: paginatedItems.length === limit ? lastItem?.id : null,
  });
});
```

### Problem 33: File Upload (Multipart Form Data)

**Question:** Handle file uploads with size limits, type validation, and storage.

```typescript
import express, { Request, Response, NextFunction } from "express";
import { mkdir, writeFile, unlink } from "fs/promises";
import path from "path";
import { randomUUID } from "crypto";
import { Readable } from "stream";

const app = express();

const UPLOAD_DIR = path.join(__dirname, "uploads");
const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
const ALLOWED_TYPES = [
  "image/jpeg",
  "image/png",
  "image/gif",
  "application/pdf",
];

// Ensure upload directory exists
await mkdir(UPLOAD_DIR, { recursive: true });

interface UploadedFile {
  fieldname: string;
  filename: string;
  originalname: string;
  mimetype: string;
  size: number;
  path: string;
}

interface MulterRequest extends Request {
  file?: UploadedFile;
  files?: UploadedFile[];
}

// Simple multipart parser (in production, use multer or busboy)
// This demonstrates the concept
async function parseMultipart(req: Request): Promise<{
  fields: Record<string, string>;
  files: UploadedFile[];
}> {
  return new Promise((resolve, reject) => {
    const contentType = req.headers["content-type"] ?? "";

    if (!contentType.includes("multipart/form-data")) {
      reject(new Error("Content-Type must be multipart/form-data"));
      return;
    }

    // Extract boundary from content-type
    const boundaryMatch = contentType.match(/boundary=(.+)$/);
    if (!boundaryMatch) {
      reject(new Error("No boundary found"));
      return;
    }

    // In production, use a proper multipart parser library
    // This is simplified for demonstration
    const chunks: Buffer[] = [];

    req.on("data", (chunk) => chunks.push(chunk));
    req.on("end", () => {
      // Parse multipart data here...
      // For interview purposes, we'll use multer instead
      resolve({ fields: {}, files: [] });
    });
    req.on("error", reject);
  });
}

// Using multer (the standard approach)
// npm install multer @types/multer
import multer from "multer";

// Configure storage
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, UPLOAD_DIR);
  },
  filename: function (req, file, cb) {
    // Generate unique filename: timestamp-uuid.ext
    const ext = path.extname(file.originalname);
    const filename = `${Date.now()}-${randomUUID()}${ext}`;
    cb(null, filename);
  },
});

// File filter for validation
function fileFilter(
  req: Request,
  file: Express.Multer.File,
  cb: multer.FileFilterCallback,
): void {
  if (ALLOWED_TYPES.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error(`File type ${file.mimetype} not allowed`));
  }
}

const upload = multer({
  storage,
  limits: {
    fileSize: MAX_FILE_SIZE,
    files: 5, // Max 5 files per request
  },
  fileFilter,
});

// Single file upload
app.post(
  "/upload/single",
  upload.single("file"),
  function (req: MulterRequest, res: Response) {
    if (!req.file) {
      res.status(400).json({ error: "No file uploaded" });
      return;
    }

    res.status(201).json({
      message: "File uploaded successfully",
      file: {
        filename: req.file.filename,
        originalname: req.file.originalname,
        mimetype: req.file.mimetype,
        size: req.file.size,
        url: `/files/${req.file.filename}`,
      },
    });
  },
);

// Multiple files upload
app.post(
  "/upload/multiple",
  upload.array("files", 5),
  function (req: MulterRequest, res: Response) {
    if (!req.files || req.files.length === 0) {
      res.status(400).json({ error: "No files uploaded" });
      return;
    }

    const files = (req.files as UploadedFile[]).map((file) => ({
      filename: file.filename,
      originalname: file.originalname,
      size: file.size,
    }));

    res.status(201).json({
      message: `${files.length} files uploaded`,
      files,
    });
  },
);

// Upload with additional fields
app.post(
  "/upload/with-data",
  upload.single("avatar"),
  function (req: MulterRequest, res: Response) {
    const { username, bio } = req.body;

    res.json({
      user: { username, bio },
      avatar: req.file?.filename,
    });
  },
);

// Error handling for multer
app.use(function (err: Error, req: Request, res: Response, next: NextFunction) {
  if (err instanceof multer.MulterError) {
    if (err.code === "LIMIT_FILE_SIZE") {
      res.status(413).json({
        error: `File too large. Max size: ${MAX_FILE_SIZE / 1024 / 1024}MB`,
      });
      return;
    }
    if (err.code === "LIMIT_FILE_COUNT") {
      res.status(400).json({ error: "Too many files" });
      return;
    }
    res.status(400).json({ error: err.message });
    return;
  }

  if (err.message.includes("not allowed")) {
    res.status(415).json({ error: err.message });
    return;
  }

  next(err);
});

// Serve uploaded files
app.use("/files", express.static(UPLOAD_DIR));

// Delete uploaded file
app.delete("/files/:filename", async function (req: Request, res: Response) {
  const { filename } = req.params;

  // Prevent directory traversal
  const safeName = path.basename(filename);
  const filePath = path.join(UPLOAD_DIR, safeName);

  try {
    await unlink(filePath);
    res.status(204).send();
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === "ENOENT") {
      res.status(404).json({ error: "File not found" });
    } else {
      throw error;
    }
  }
});
```

### Problem 34: Caching Headers (ETag & Conditional Requests)

**Question:** Implement ETag-based caching with conditional GET requests.

```typescript
import express, { Request, Response, NextFunction } from "express";
import { createHash } from "crypto";

const app = express();

// Simulated database with version tracking
interface Resource {
  id: string;
  data: string;
  updatedAt: Date;
}

const resources = new Map<string, Resource>([
  ["1", { id: "1", data: "Hello World", updatedAt: new Date("2024-01-01") }],
  [
    "2",
    { id: "2", data: "Another resource", updatedAt: new Date("2024-01-15") },
  ],
]);

// Generate ETag from content
function generateETag(content: string): string {
  const hash = createHash("md5").update(content).digest("hex");
  return `"${hash}"`; // ETags should be quoted strings
}

// Generate weak ETag (for semantically equivalent content)
function generateWeakETag(content: string): string {
  const hash = createHash("md5").update(content).digest("hex").slice(0, 8);
  return `W/"${hash}"`;
}

// ETag middleware for responses
function etag(req: Request, res: Response, next: NextFunction): void {
  const originalJson = res.json.bind(res);

  res.json = function (body: unknown) {
    const content = JSON.stringify(body);
    const etagValue = generateETag(content);

    // Check If-None-Match header (client's cached ETag)
    const clientETag = req.headers["if-none-match"];

    if (clientETag === etagValue) {
      // Client has fresh copy, return 304
      res.status(304).end();
      return res;
    }

    // Set ETag and caching headers
    res.setHeader("ETag", etagValue);
    res.setHeader("Cache-Control", "private, max-age=0, must-revalidate");

    return originalJson(body);
  };

  next();
}

app.use(etag);

// GET with ETag support
app.get("/resources/:id", function (req: Request, res: Response) {
  const resource = resources.get(req.params.id);

  if (!resource) {
    res.status(404).json({ error: "Resource not found" });
    return;
  }

  // Set Last-Modified header
  res.setHeader("Last-Modified", resource.updatedAt.toUTCString());

  res.json(resource);
});

// Conditional PUT (prevent lost updates)
app.put(
  "/resources/:id",
  express.json(),
  function (req: Request, res: Response) {
    const resource = resources.get(req.params.id);

    if (!resource) {
      res.status(404).json({ error: "Resource not found" });
      return;
    }

    // Check If-Match header (client must provide current ETag)
    const clientETag = req.headers["if-match"];
    const currentETag = generateETag(JSON.stringify(resource));

    if (!clientETag) {
      // Require ETag for updates to prevent conflicts
      res.status(428).json({
        error: "Precondition Required",
        message: "If-Match header required for updates",
      });
      return;
    }

    if (clientETag !== currentETag) {
      // Resource was modified since client last fetched it
      res.status(412).json({
        error: "Precondition Failed",
        message: "Resource has been modified. Fetch latest version and retry.",
      });
      return;
    }

    // Update resource
    resource.data = req.body.data;
    resource.updatedAt = new Date();

    res.json(resource);
  },
);

// Static assets with long cache
app.get("/static/:file", function (req: Request, res: Response) {
  const content = `Static content for ${req.params.file}`;

  // Immutable content - cache for 1 year
  res.setHeader("Cache-Control", "public, max-age=31536000, immutable");
  res.setHeader("ETag", generateETag(content));

  res.send(content);
});

// API responses with short cache
app.get("/api/data", function (req: Request, res: Response) {
  const data = { timestamp: Date.now(), value: Math.random() };

  // Cache for 60 seconds, but revalidate
  res.setHeader(
    "Cache-Control",
    "public, max-age=60, stale-while-revalidate=30",
  );

  res.json(data);
});

// No-cache response (always revalidate)
app.get("/api/user/session", function (req: Request, res: Response) {
  res.setHeader("Cache-Control", "no-cache, no-store, must-revalidate");
  res.setHeader("Pragma", "no-cache"); // HTTP/1.0 compatibility
  res.setHeader("Expires", "0");

  res.json({ sessionId: "abc123", expiresAt: Date.now() + 3600000 });
});
```

### Problem 35: SQL Injection Prevention (Parameterized Queries)

**Question:** Demonstrate safe database queries using parameterized statements.

```typescript
import express, { Request, Response } from "express";
// Using pg (node-postgres) as example - patterns apply to any SQL library
import { Pool } from "pg";

const app = express();
app.use(express.json());

const pool = new Pool({
  host: process.env.DB_HOST ?? "localhost",
  port: parseInt(process.env.DB_PORT ?? "5432"),
  database: process.env.DB_NAME ?? "myapp",
  user: process.env.DB_USER ?? "postgres",
  password: process.env.DB_PASSWORD ?? "password",
});

// ❌ VULNERABLE - Never do this!
app.get("/users/vulnerable", async function (req: Request, res: Response) {
  const { id } = req.query;

  // SQL Injection vulnerability - user input directly in query
  // Attacker could pass: id = "1; DROP TABLE users; --"
  const query = `SELECT * FROM users WHERE id = ${id}`;

  const result = await pool.query(query); // DANGEROUS!
  res.json(result.rows);
});

// ✅ SAFE - Parameterized query
app.get("/users/:id", async function (req: Request, res: Response) {
  const { id } = req.params;

  try {
    // $1 is a placeholder - pg library handles escaping
    const result = await pool.query(
      "SELECT id, name, email FROM users WHERE id = $1",
      [id],
    );

    if (result.rows.length === 0) {
      res.status(404).json({ error: "User not found" });
      return;
    }

    res.json(result.rows[0]);
  } catch (error) {
    console.error("Database error:", error);
    res.status(500).json({ error: "Database error" });
  }
});

// ✅ SAFE - Multiple parameters
app.get("/users", async function (req: Request, res: Response) {
  const { name, email, limit = "10", offset = "0" } = req.query;

  // Build query dynamically but safely
  const conditions: string[] = [];
  const params: (string | number)[] = [];
  let paramIndex = 1;

  if (name) {
    conditions.push(`name ILIKE $${paramIndex}`);
    params.push(`%${name}%`); // LIKE pattern
    paramIndex++;
  }

  if (email) {
    conditions.push(`email = $${paramIndex}`);
    params.push(email as string);
    paramIndex++;
  }

  // Validate and sanitize limit/offset (must be numbers)
  const safeLimit = Math.min(
    100,
    Math.max(1, parseInt(limit as string, 10) || 10),
  );
  const safeOffset = Math.max(0, parseInt(offset as string, 10) || 0);

  let query = "SELECT id, name, email FROM users";

  if (conditions.length > 0) {
    query += ` WHERE ${conditions.join(" AND ")}`;
  }

  query += ` ORDER BY id LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
  params.push(safeLimit, safeOffset);

  try {
    const result = await pool.query(query, params);
    res.json(result.rows);
  } catch (error) {
    console.error("Database error:", error);
    res.status(500).json({ error: "Database error" });
  }
});

// ✅ SAFE - Insert with returning
app.post("/users", async function (req: Request, res: Response) {
  const { name, email, password } = req.body;

  // Validate input
  if (!name || !email || !password) {
    res.status(400).json({ error: "Name, email, and password required" });
    return;
  }

  try {
    // In real app, hash password first
    const hashedPassword = `hashed_${password}`; // Use bcrypt in production!

    const result = await pool.query(
      `INSERT INTO users (name, email, password_hash, created_at) 
       VALUES ($1, $2, $3, NOW()) 
       RETURNING id, name, email, created_at`,
      [name, email, hashedPassword],
    );

    res.status(201).json(result.rows[0]);
  } catch (error) {
    // Handle unique constraint violation
    if ((error as { code?: string }).code === "23505") {
      res.status(409).json({ error: "Email already exists" });
      return;
    }
    throw error;
  }
});

// ✅ SAFE - Transaction with parameterized queries
app.post("/transfer", async function (req: Request, res: Response) {
  const { fromAccountId, toAccountId, amount } = req.body;

  // Validate amount
  const transferAmount = parseFloat(amount);
  if (Number.isNaN(transferAmount) || transferAmount <= 0) {
    res.status(400).json({ error: "Invalid amount" });
    return;
  }

  const client = await pool.connect();

  try {
    await client.query("BEGIN");

    // Debit from source account
    const debitResult = await client.query(
      `UPDATE accounts 
       SET balance = balance - $1 
       WHERE id = $2 AND balance >= $1
       RETURNING balance`,
      [transferAmount, fromAccountId],
    );

    if (debitResult.rows.length === 0) {
      await client.query("ROLLBACK");
      res
        .status(400)
        .json({ error: "Insufficient funds or account not found" });
      return;
    }

    // Credit to destination account
    const creditResult = await client.query(
      `UPDATE accounts 
       SET balance = balance + $1 
       WHERE id = $2
       RETURNING balance`,
      [transferAmount, toAccountId],
    );

    if (creditResult.rows.length === 0) {
      await client.query("ROLLBACK");
      res.status(404).json({ error: "Destination account not found" });
      return;
    }

    // Record transaction
    await client.query(
      `INSERT INTO transactions (from_account, to_account, amount, created_at)
       VALUES ($1, $2, $3, NOW())`,
      [fromAccountId, toAccountId, transferAmount],
    );

    await client.query("COMMIT");

    res.json({
      message: "Transfer successful",
      fromBalance: debitResult.rows[0].balance,
      toBalance: creditResult.rows[0].balance,
    });
  } catch (error) {
    await client.query("ROLLBACK");
    throw error;
  } finally {
    client.release();
  }
});

// ✅ SAFE - Dynamic column selection (whitelist approach)
app.get("/users/:id/fields", async function (req: Request, res: Response) {
  const { id } = req.params;
  const requestedFields = (req.query.fields as string)?.split(",") ?? [];

  // Whitelist of allowed columns - NEVER use user input directly as column names
  const allowedFields = ["id", "name", "email", "created_at", "updated_at"];

  const selectedFields = requestedFields.filter((f) =>
    allowedFields.includes(f),
  );

  if (selectedFields.length === 0) {
    selectedFields.push("id", "name", "email"); // Default fields
  }

  // Safe because we're using whitelisted column names, not user input
  const query = `SELECT ${selectedFields.join(", ")} FROM users WHERE id = $1`;

  try {
    const result = await pool.query(query, [id]);
    res.json(result.rows[0] ?? null);
  } catch (error) {
    console.error("Database error:", error);
    res.status(500).json({ error: "Database error" });
  }
});
```

### Problem 36: Integration Testing with Supertest

**Question:** Write integration tests for Express routes using supertest.

```typescript
// app.ts - Export app without listening
import express, { Request, Response, NextFunction } from "express";

export const app = express();
app.use(express.json());

interface Todo {
  id: string;
  title: string;
  completed: boolean;
}

export const todos = new Map<string, Todo>();

app.get("/todos", function (req: Request, res: Response) {
  res.json(Array.from(todos.values()));
});

app.get("/todos/:id", function (req: Request, res: Response) {
  const todo = todos.get(req.params.id);

  if (!todo) {
    res.status(404).json({ error: "Todo not found" });
    return;
  }

  res.json(todo);
});

app.post("/todos", function (req: Request, res: Response) {
  const { title } = req.body;

  if (!title) {
    res.status(400).json({ error: "Title is required" });
    return;
  }

  const todo: Todo = {
    id: Date.now().toString(),
    title,
    completed: false,
  };

  todos.set(todo.id, todo);
  res.status(201).json(todo);
});

app.patch("/todos/:id", function (req: Request, res: Response) {
  const todo = todos.get(req.params.id);

  if (!todo) {
    res.status(404).json({ error: "Todo not found" });
    return;
  }

  const { title, completed } = req.body;
  if (title !== undefined) todo.title = title;
  if (completed !== undefined) todo.completed = completed;

  res.json(todo);
});

app.delete("/todos/:id", function (req: Request, res: Response) {
  if (!todos.delete(req.params.id)) {
    res.status(404).json({ error: "Todo not found" });
    return;
  }

  res.status(204).send();
});

// Error handler
app.use(function (err: Error, req: Request, res: Response, next: NextFunction) {
  console.error(err);
  res.status(500).json({ error: "Internal server error" });
});

// ============================================
// app.test.ts - Test file using Vitest + Supertest
// npm install -D vitest supertest @types/supertest
// ============================================
import { describe, it, expect, beforeEach } from "vitest";
import request from "supertest";
import { app, todos } from "./app";

describe("Todos API", function () {
  // Reset state before each test
  beforeEach(function () {
    todos.clear();
  });

  describe("GET /todos", function () {
    it("should return empty array when no todos exist", async function () {
      const response = await request(app)
        .get("/todos")
        .expect("Content-Type", /json/)
        .expect(200);

      expect(response.body).toEqual([]);
    });

    it("should return all todos", async function () {
      // Arrange - add test data
      todos.set("1", { id: "1", title: "Test todo", completed: false });
      todos.set("2", { id: "2", title: "Another todo", completed: true });

      // Act
      const response = await request(app).get("/todos").expect(200);

      // Assert
      expect(response.body).toHaveLength(2);
      expect(response.body[0]).toHaveProperty("title", "Test todo");
    });
  });

  describe("GET /todos/:id", function () {
    it("should return todo by id", async function () {
      todos.set("123", { id: "123", title: "My todo", completed: false });

      const response = await request(app).get("/todos/123").expect(200);

      expect(response.body).toMatchObject({
        id: "123",
        title: "My todo",
        completed: false,
      });
    });

    it("should return 404 for non-existent todo", async function () {
      const response = await request(app).get("/todos/nonexistent").expect(404);

      expect(response.body).toEqual({ error: "Todo not found" });
    });
  });

  describe("POST /todos", function () {
    it("should create a new todo", async function () {
      const response = await request(app)
        .post("/todos")
        .send({ title: "New todo" })
        .set("Content-Type", "application/json")
        .expect(201);

      expect(response.body).toMatchObject({
        title: "New todo",
        completed: false,
      });
      expect(response.body).toHaveProperty("id");

      // Verify it was actually stored
      expect(todos.size).toBe(1);
    });

    it("should return 400 when title is missing", async function () {
      const response = await request(app).post("/todos").send({}).expect(400);

      expect(response.body).toEqual({ error: "Title is required" });
      expect(todos.size).toBe(0);
    });

    it("should return 400 when title is empty string", async function () {
      await request(app).post("/todos").send({ title: "" }).expect(400);
    });
  });

  describe("PATCH /todos/:id", function () {
    it("should update todo title", async function () {
      todos.set("1", { id: "1", title: "Original", completed: false });

      const response = await request(app)
        .patch("/todos/1")
        .send({ title: "Updated" })
        .expect(200);

      expect(response.body.title).toBe("Updated");
      expect(response.body.completed).toBe(false); // Unchanged
    });

    it("should update todo completed status", async function () {
      todos.set("1", { id: "1", title: "Todo", completed: false });

      const response = await request(app)
        .patch("/todos/1")
        .send({ completed: true })
        .expect(200);

      expect(response.body.completed).toBe(true);
    });

    it("should return 404 for non-existent todo", async function () {
      await request(app)
        .patch("/todos/nonexistent")
        .send({ title: "Test" })
        .expect(404);
    });
  });

  describe("DELETE /todos/:id", function () {
    it("should delete existing todo", async function () {
      todos.set("1", { id: "1", title: "To delete", completed: false });

      await request(app).delete("/todos/1").expect(204);

      expect(todos.has("1")).toBe(false);
    });

    it("should return 404 for non-existent todo", async function () {
      await request(app).delete("/todos/nonexistent").expect(404);
    });
  });

  describe("Authentication scenarios", function () {
    it("should handle authenticated requests", async function () {
      // Example with Bearer token
      const response = await request(app)
        .get("/todos")
        .set("Authorization", "Bearer valid-token")
        .expect(200);

      expect(response.body).toEqual([]);
    });
  });

  describe("Edge cases", function () {
    it("should handle special characters in todo title", async function () {
      const response = await request(app)
        .post("/todos")
        .send({ title: "Test <script>alert('xss')</script>" })
        .expect(201);

      expect(response.body.title).toContain("<script>");
    });

    it("should handle unicode in todo title", async function () {
      const response = await request(app)
        .post("/todos")
        .send({ title: "买牛奶 🥛" })
        .expect(201);

      expect(response.body.title).toBe("买牛奶 🥛");
    });

    it("should handle concurrent requests", async function () {
      // Create multiple todos simultaneously
      const promises = Array.from({ length: 10 }, (_, i) =>
        request(app)
          .post("/todos")
          .send({ title: `Todo ${i}` }),
      );

      const responses = await Promise.all(promises);

      responses.forEach((response) => {
        expect(response.status).toBe(201);
      });

      expect(todos.size).toBe(10);
    });
  });
});

// ============================================
// Run tests with: npx vitest
// Or add to package.json: "test": "vitest"
// ============================================
```
